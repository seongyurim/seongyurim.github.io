---
layout: post
title: "[모던 자바스크립트 11장] 원시 값과 객체의 비교"
date: 2024-10-23
categories: [Book, 모던 자바스크립트 Deep Dive]
tags: []
---

<table style="text-align: center;">
  <thead>
    <tr>
      <th></th>
      <th>Primitive Type</th>
      <th>Object/Reference Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>변경 가능 여부</b></td>
      <td>변경 불가능한 값<br>(immutable value)</td>
      <td>변경 가능한 값<br>(mutable value)</td>
    </tr>
    <tr>
      <td><b>변수 메모리에 저장되는 데이터</b></td>
      <td>원시 값을 변수에 할당하면<br>실제 값이 저장</td>
      <td>원시 값을 변수에 할당하면<br>참조 값이 저장</td>
    </tr>
    <tr>
      <td><b>변수 값을 다른 변수에 할당</b></td>
      <td>원시 값이 복사되어 전달<br>(pass by value)</td>
      <td>참조 값이 복사되어 전달<br>(pass by reference)</td>
    </tr>
  </tbody>
</table>

## 1. 원시 값

### 1.1. 변경 불가능한 값

- 원시 값은 변경 불가능한 값이기 때문에 값을 직접 변경할 수 없다.
- 따라서 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보한다.
- 그리고 재할당한 값을 저장한 뒤에, 변수가 참조하던 메모리 공간의 주소를 변경한다.
- 값의 이러한 특성을 **불변성(immutability)**이라 한다.
- 원시값을 할당받은 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.
<figure>
	<img src="https://velog.velcdn.com/images/tngustkdehs/post/09c6de6e-adc5-4b9a-b75f-8a30ed8af4f2/image.png" alt="Modern JavaScript Deep Dive">
	<figcaption>velog.io/@n-u-002</figcaption>
</figure>

### 1.2. 문자열과 불변성

- 자바에서는 문자열을 String 객체로 처리한다.
- 하지만 자바스크립트는 개발자의 편의를 위해 문자열 타입을 원시 타입으로 제공한다.
- 자바스크립트의 문자열은 원시 타입이며 변경 불가능하다.
- 또한 문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.
- **유사 배열 객체(array-like object)**: 배열처럼 인덱스로 접근이 가능하고, length 프로퍼티를 갖는 객체
- 하지만 각 문자만을 변경하는 것은 불가능하다. 이는 데이터의 신뢰성을 보장한다.

```javascript
let str = "string";

console.log(str[0]); // s 배열처럼 인덱스로 접근
console.log(str.length); // 6 원시값인 문자열이 객체처럼 동작

str[0] = "S"; // 반영 불가능하며 오류가 발생하지도 않음
console.log(str); // string 반영되지 않았음
```

### 1.3. 값에 의한 전달

```javascript
let score = 80;
let copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // 80
```

- 값에 의한 전달: 변수에 원시 값을 갖는 변수를 할당하면, 할당받는 변수(copy)에는 할당되는 변수(score)의 **원시 값이 복사되어 전달**된다. _('공유에 의한 전달'이라고 표현하는 경우도 있다.)_
- score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.
- 엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달된다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다. 왜냐하면 식별자는 값이 아니라 메모리 주소에 붙인 이름이기 때문이다.
- 중요한 것은, 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것이다.

## 2. 객체

- 객체의 기본적인 특징
  - 프로퍼티의 개수가 정해져 있지 않다.
  - 동적으로 추가되고 삭제할 수 있다.
  - 프로퍼티의 값에도 제약이 없다.
  - 확보해야 할 메모리 공간의 크기를 미리 정해둘 수 없다.
- 자바스크립트의 객체 관리 방식
  - 자바는 프로퍼티와 메서드를 사전에 정의한 클래스를 기반으로 인스턴스를 생성한다.
  - 객체가 생성된 이후에는 프로퍼티를 삭제하거나 추가할 수 없다.
  - 반면 자바스크립트는 클래스 없이 객체를 생성할 수 있으며 객체 생성 이후에도 프로퍼티와 메서드를 동적으로 추가할 수 있다.
  - 따라서 V8 엔진은 프로퍼티 접근을 위해 동적 탐색 대신 히든 클래스라는 방식을 사용한다.
  - 이를 통해 C++ 객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.
  - 히든 클래스 개념을 이해하기 위해 [이 포스트](https://engineering.linecorp.com/ko/blog/v8-hidden-class)를 읽어 보자.

### 2.1. 변경 가능한 값

```javascript
let person = {
  name: 'Lee';
};

// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 생성
person.address = 'Seoul';

console.log(person); // {name: 'Kim', address: 'Seoul'}
```

- 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.
- 즉, 재할당 없이 프로퍼티를 동적으로 추가, 갱신, 삭제가 모두 가능하다는 의미이다.
- 객체가 변경 가능한 값인 이유: 메모리의 효율적 사용, 객체를 복사해 생성하는 비용을 절약하여 성능 향상
- 객체의 구조적 단점에 따른 부작용: 여러 개의 식별자가 하나의 객체 공유 가능
- 얕은 복사(shallow copy)와 깊은 복사(deep copy)
  - 얕은 복사: 객체의 최상위 레벨 속성들만 복사하고, 그 속성들이 객체일 경우 원래 객체의 참조를 복사
  - 깊은 복사: 객체의 모든 레벨의 속성들을 재귀적으로 복사하여 원본 객체와 독립적인 새로운 객체 생성
  - 참고로 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사, 객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라고 부르는 경우도 있다.

### 2.2. 참조에 의한 전달

- 여러 개의 식별자가 하나의 객체를 공유할 수 있다.
- 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
- 결국 '값에 의한 전달'과 '참조에 의한 전달'은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.
- 다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다.
- 따라서 자바스크립트에는 '참조에 의한 전달'은 존재하지 않고 '값에 의한 전달'만 존재한다고 할 수 있다.
- 아래 퀴즈를 풀어보자.

```javascript
let person1 = {
  name: "Lee"
};

let person2 = {
  name: "Lee"
};

console.log(person1 === person2); // ①
console.log(person1.name === person2.name); // ②
```

- 일치 비교 연산자(===)는 타입 변환 없이 그대로 비교한다.
- 일치 비교 연산자의 대상이 **객체이면 참조 값을 비교하고, 원시 값이면 그 원시값 자체를 비교**한다.
- ① false: person1, person2는 동일 내용이지만 서로 다른 별개의 객체이기 때문이다.
- ② true: 'perseon1.name'은 값으로 평가될 수 있는 표현식('Lee')이기 때문이다.
